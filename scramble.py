#!/usr/bin/env python
import sys, re, os, StringIO

guard_prefix = ""
if len(sys.argv) > 4:
    egg = sys.argv[1]
    fin = file(egg)
    fot = file(sys.argv[2], "w")
    real_hot = file(sys.argv[3], "w")
    hot = StringIO.StringIO()
    typedefs = StringIO.StringIO()
    name = sys.argv[4]
    if len(sys.argv) > 5:
        guard_prefix = sys.argv[5]
else:
    sys.stderr.write("scramble source.py target.c target.h target [guard_prefix]\n")
    sys.exit(-1)

guard = guard_prefix + "_" + name.upper().replace("/", "_") + "_"

blah = "/* This file was generated by scramble.py. */"

to = fot

to.write("""
%s
#line 1 "%s"
#include "%s.h"
#ifdef None
#undef None
#endif
#define None NULL
""".lstrip() % (blah, egg, name))

class Level:
    def __init__(self, depth = 0, is_class = False):
        self.depth = depth
        self.is_class = is_class
        self.is_enum = False

class Translator:
    def __init__(self):
        self.linecont = ""
        self.num = 0
        self.depths = [Level()]
        self.preprocessor_targets = ["implementation"]

def string_cb(l, cb):
    outside = ""
    inside = ""
    pos = 0
    start_pos = 0
    is_in_string = ""
    is_escaped = False
    for c in l:
        if is_escaped:
            is_escaped = False
            inside += c
        elif is_in_string:
            if c == "\\":
                is_escaped = True
                inside += c
            elif c == is_in_string:
                is_in_string = ""
                inside += c
                ret = cb(True, start_pos, inside)
                if ret != None: return ret
                start_pos = pos + 1
            else:
                inside += c
        elif c in ['"', "'"]:
            is_in_string = c
            if outside:
                ret = cb(False, start_pos, outside)
                if ret != None: return ret
                outside = ""
            start_pos = pos
            inside = c
        else:
            outside += c
        pos += 1

    if outside:
        return cb(False, start_pos, outside)
    return None

def parenthesis_balance(l, x, y):
    b = 0
    s = 0
    e = 0
    for c in l:
        if e:
            e = 0
        elif s:
            if c == "\\":
                e = 1
            elif s == 1 and c == "\"":
                s = 0
            elif s == 2 and c == "'":
                s = 0
        elif c == "\"":
            s = 1
        elif c == "'":
            s = 2
        elif c == x:
            b += 1
        elif c == y:
            b -= 1
    return b

def colon_find(l):
    mob = re.compile("\s*(\w+)").match(l)
    if mob and not mob.group(1) in ["for", "if", "while", "else", "elif"]: return None
    colon = None
    s = 0
    e = 0
    for i in range(len(l)):
        c = l[i]
        if e:
            e = 0
        elif s:
            if c == "\\":
                e = 1
            elif s == 1 and c == "\"":
                s = 0
            elif s == 2 and c == "'":
                s = 0
        elif c == "\"":
            s = 1
        elif c == "'":
            s = 2
        elif c == ":":
            colon = i
    return colon

def outside_string_replace(l, repl, with):
    out = [""]
    def cb(is_string, pos, sub):
        if is_string:
            out[0] += sub
        else:
            out[0] += re.compile(repl).sub(with, sub)

    string_cb(l, cb)

    return out[0]

def outside_string_find(l, what):
    def cb(is_string, pos, sub):
        pos2 = sub.find(what)
        if pos2 >= 0: return pos + pos2
    ret = string_cb(l, cb)
    if ret == None: return -1
    return ret

def translate_conditional_params(params):
    params = outside_string_replace(params, r"\bor\b", "||")
    params = outside_string_replace(params, r"\band\b", "&&")
    params = outside_string_replace(params, r"\bnot\b", "!")
    return params

def translate_def(self, l):
    global to
    mob = re.compile(r"\s*(.*?)\s*def\s*(\w+?)\s*\((.*)\)").match(l)
    if not mob:
        sys.stderr.write("%d: Error, no function!\n" % self.num)
    else:
        retval = mob.group(1)
        name = mob.group(2)
        params = mob.group(3)
        if retval == "": retval = "void"
        if retval in ["static", "inline static", "static inline"]: retval += " void"
        if params == "": params = "void"

        static = "static" in retval.split()

        params2 = []
        last_type = "int"
        for p in params.split(","):
            p = p.strip()
            x = p.split(" ", 1)
            if p == "...":
                params2.append(p)
            elif len(x) == 1 and p != "void":
                params2.append(last_type + " " + p)
            else:
                params2.append(p)
                last_type = x[0]
        params = ", ".join(params2)
        if not static:
            hot.write("#line %d\n" % self.num)
            hot.write("%s %s(%s);\n" % (retval, name, params))
        to.write("%s %s(%s)\n" % (retval, name, params))

def translate_import(self, t, names):
    q = ('"', '"')
    for name in names:
        name = name.strip()
        if name.startswith("global "):
            q = ("<", ">")
            name = name[7:].strip()
        if name:
            t.write("#include %s%s.h%s\n" % (q[0], name, q[1]))

def handle_line(self, l):
    global to

    d = 0
    while l[d] == " ": d += 1
    if d > self.depths[-1].depth:
        to.write(" " * self.depths[-1].depth + "{\n")
        to.write("#line %d\n" % self.num)
        self.depths.append(Level(d))
        self.depths[-1].is_enum = self.depths[-2].is_enum
    elif d < self.depths[-1].depth:
        while d < self.depths[-1].depth:
            self.depths.pop()
            if self.depths[-1].is_class:
                to.write(" " * self.depths[-1].depth + "};\n")
                to = fot
                self.depths[-1].is_class = False
            elif self.depths[-1].is_enum:
                to.write(" " * self.depths[-1].depth + "};\n")
                to = fot
                self.depths[-1].is_enum = False
            else:
                to.write(" " * self.depths[-1].depth + "}\n")
        to.write("#line %d\n" % self.num)

    l = l.strip()

    to.write(" " * self.depths[-1].depth)
    if l[-1] == ":":
        if l == "end:":
            pass
        elif re.compile(r"class\b").match(l):
            params = l[5:-1].strip()
            typedefs.write("typedef struct %s %s;\n" % (params, params))
            hot.write("struct %s\n" % params)
            to = hot
            self.depths[-1].is_class = True
        elif re.compile(r"enum\b").match(l):
            params = l[4:-1].strip()
            typedefs.write("typedef enum %s %s;\n" % (params, params))
            hot.write("enum %s\n" % params)
            to = hot
            self.depths[-1].is_enum = True
        elif re.compile(r"do\b").match(l):
            params = l[2:-1].strip()
            to.write("do %s\n" % params)
        elif re.compile(r"for\b").match(l):
            params = l[3:-1].strip()
            to.write("for (%s)\n" % translate_conditional_params(params))
        elif re.compile(r"while\b").match(l):
            params = l[5:-1].strip()
            to.write("while (%s)\n" % translate_conditional_params(params))
        elif re.compile(r"switch\b").match(l):
            params = l[6:-1].strip()
            to.write("switch (%s)\n" % params)
        elif re.compile(r"\bif\b").match(l):
            params = l[2:-1].strip()
            to.write("if (%s)\n" % translate_conditional_params(params))
        elif re.compile(r"\belif\b").match(l):
            params = l[4:-1].strip()
            to.write("else if (%s)\n" % translate_conditional_params(params))
        elif re.compile(r"else\b").match(l):
            to.write("else\n")
        elif re.compile(r"\bdef\b").search(l):
            translate_def(self, l)
        else:
            to.write(l + ";\n")
    elif l.startswith("static macro "):
        define = l[len("static macro "):]
        to.write("#define %s\n" % define)
    elif l.startswith("macro "):
        define = l[len("macro "):]
        hot.write("#define %s\n" % define)
    elif l.startswith("import "):
        names = l[len("import "):].split(",")
        translate_import(self, hot, names)
    elif l.startswith("static import "):
        names = l[len("static import "):].split(",")
        translate_import(self, to, names)
    elif l.startswith("global "):
        l = l[len("global "):]
        to.write(l + ";\n")
        assign = outside_string_find(l, "=")
        if assign >= 0: l2 = l[:assign].rstrip()
        else: l2 = l
        hot.write("extern " + l2 + ";\n")
    elif l.startswith("label "):
        l = l[len("label "):]
        to.write("%s:;\n" % l)
    elif re.compile(r"pass").match(l):
        to.write("/* pass */\n")
    elif l == "#both":
        self.preprocessor_targets = ["header", "implementation"]
    elif l == "#header":
        self.preprocessor_targets = ["header"]
    elif l == "#implementation":
        self.preprocessor_targets = ["implementation"]
    elif l.startswith("#"):
        if "header" in self.preprocessor_targets:
            hot.write(l + "\n")
        if "implementation" in self.preprocessor_targets:
            to.write(l + "\n")
    else:
        if self.depths[-1].is_enum:
            to.write(l + ",\n")
        else:
            to.write(l + ";\n")

def translate():
    self = Translator()
    for l in fin.readlines() + ["end:"]:
        self.num += 1

        if self.linecont:
            l = self.linecont.rstrip() + " " + l.lstrip()
            self.linecont = ""

        # Remove comments.
        c = outside_string_find(l, "#")
        if c >= 0:
            if not l.strip().split()[0] in ["#if", "#ifdef", "#ifndef", "#endif", "#else",
                "#undef", "#define", "#include", "#header", "#implementation",
                "#both"]:
                l = l[:c]

        b = parenthesis_balance(l, "{", "}")
        if b > 0:
            self.linecont = l
            continue

        b = parenthesis_balance(l, "(", ")")
        if b > 0:
            self.linecont = l
            continue

        b = parenthesis_balance(l, "[", "]")
        if b > 0:
            self.linecont = l
            continue

        if not l.strip():
            to.write("\n") # so line numbers will match
            continue

        if l.rstrip()[-1] == "\\":
            self.linecont = l.rstrip()[:-1]
            continue

        colon = colon_find(l)
        if colon != None:
            l1 = l[:colon + 1]
            handle_line(self, l1)
            l2 = " " * (self.depths[-1].depth + 4) + l[colon + 1:].strip()
            if l2.strip():
                handle_line(self, l2)
        else:
            handle_line(self, l)

translate()

to.write(blah + "\n")
hot.write("#endif\n")
hot.write(blah + "\n")

real_hot.write("""
%s
#line 1 "%s"
#ifndef %s
#define %s
""".lstrip() % (blah, egg, guard, guard))

real_hot.write(typedefs.getvalue())
real_hot.write(hot.getvalue())
