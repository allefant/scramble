#!/usr/bin/env python
import sys, re, os, StringIO, optparse, textwrap

class Level:
    def __init__(self, depth = 0, is_class = False):
        self.depth = depth
        self.is_class = is_class
        self.is_enum = False
        self.is_function = False
        self.is_static = False
        self.is_union = False
        self.name = ""
        self.definition = ""
        self.the_doc = ""

class Translator:
    def __init__(self, fin, fot, hot, name, egg, guard_prefix = "", dot = None):
        self.linecont = ""
        self.num = 0
        self.depths = [Level()]
        self.preprocessor_targets = ["implementation"]
        self.fin = fin
        self.fot = fot
        self.real_hot = hot
        self.hot = StringIO.StringIO()
        self.typedefs = StringIO.StringIO()
        self.to = fot
        self.dot = dot
        self.numbering = True

        self.guard = guard_prefix + "_" + name.upper().replace("/", "_") + "_"

        self.blah = "/* This file was generated by scramble.py. */"
        self.egg = egg
        self.name = name

        self.docstring = None

    def header(self):
        self.to.write("""
%s%s
#include "%s.h"
#undef None
#undef min
#undef max
#define None NULL
#define min(x, y) ((y) < (x) ? (y) : (x))
#define max(x, y) ((y) > (x) ? (y) : (x))
""".lstrip() % (self.blah,
        self.numbering and '\n#line 1 "%s"' % self.egg or "",
        self.name))

    def footer(self):
        self.to.write(self.blah + "\n")
        self.hot.write("#endif\n")
        self.hot.write(self.blah + "\n")

        self.real_hot.write("""
%s%s
#ifndef %s
#define %s
""".lstrip() % (self.blah,
        self.numbering and '\n#line 1 "%s"' % self.egg or "",
        self.guard, self.guard))

        self.real_hot.write(self.typedefs.getvalue())
        self.real_hot.write(self.hot.getvalue())

    def add_to_docstring(self, l):
        self.docstring += l
        if self.docstring.rstrip().endswith('"""'):
            self.docstring = self.docstring.rstrip()[:-3]
            lines = self.docstring.splitlines()
            doc = lines[0]
            if len(lines) > 1:
                doc += "\n" + textwrap.dedent("\n".join(lines[1:]))
            self.depths[-1].the_doc = doc.strip()

            self.docstring = None

            if self.numbering: self.to.write("#line %d\n" % self.num)

    def translate(self):

        for l in self.fin.readlines() + ["end:"]:
            self.num += 1

            if self.linecont:
                l = self.linecont.rstrip() + " " + l.lstrip()
                self.linecont = ""

            # Docstring continuation.
            if self.docstring != None:
                self.add_to_docstring(l)
                continue

            # Remove comments.
            c = outside_string_find(l, "#")
            if c >= 0:
                if not l.strip().split()[0] in ["#if", "#ifdef", "#ifndef", "#endif", "#else",
                    "#undef", "#define", "#include", "#header", "#implementation",
                    "#both"]:
                    l = l[:c]

            b = parenthesis_balance(l, "{", "}")
            if b > 0:
                self.linecont = l
                continue

            b = parenthesis_balance(l, "(", ")")
            if b > 0:
                self.linecont = l
                continue

            b = parenthesis_balance(l, "[", "]")
            if b > 0:
                self.linecont = l
                continue

            if not l.strip():
                if self.numbering: self.to.write("\n") # so line numbers will match
                continue

            if l.rstrip()[-1] == "\\":
                self.linecont = l.rstrip()[:-1]
                continue

            colon = colon_find(l)
            if colon != None:
                l1 = l[:colon + 1]
                self.handle_line(l1)
                l2 = " " * (self.depths[-1].depth + 4) + l[colon + 1:].strip()
                if l2.strip():
                    self.handle_line(l2)
            else:
                self.handle_line(l)

    def handle_line(self, l):

        d = 0
        while l[d] == " ": d += 1
        if d > self.depths[-1].depth:
            self.to.write(" " * self.depths[-1].depth + "{\n")
            if self.numbering: self.to.write("#line %d\n" % self.num)
            self.depths.append(Level(d))

            #FIXME: what is this for?
            self.depths[-1].is_enum = self.depths[-2].is_enum

        elif d < self.depths[-1].depth:
            while d < self.depths[-1].depth:
                the_doc = self.depths[-1].the_doc
                self.depths.pop()
                if self.depths[-1].is_class:
                    self.to.write(" " * self.depths[-1].depth + "};\n")
                    self.to = self.fot
                    self.depths[-1].is_class = False

                    if self.dot and not self.depths[-1].is_static:
                        self.dot.write('"""class %s\n' % self.depths[-1].name)
                        self.dot.write('%s\n' % self.depths[-1].definition)
                        self.dot.write("%s\n" % the_doc)
                elif self.depths[-1].is_enum:
                    self.to.write(" " * self.depths[-1].depth + "};\n")
                    self.to = self.fot
                    self.depths[-1].is_enum = False
                elif self.depths[-1].is_union:
                    self.to.write(" " * self.depths[-1].depth + "} %s;\n" %
                        self.depths[-1].name)
                    self.depths[-1].is_union = False
                elif self.depths[-1].is_function:
                    self.to.write(" " * self.depths[-1].depth + "}\n")
                    self.depths[-1].is_function = False

                    if self.dot and not self.depths[-1].is_static:
                        self.dot.write('"""def %s\n' % self.depths[-1].name)
                        self.dot.write('%s\n' % self.depths[-1].definition)
                        self.dot.write("%s\n" % the_doc)
                else:
                    self.to.write(" " * self.depths[-1].depth + "}\n")
            if self.numbering: self.to.write("#line %d\n" % self.num)

        l = l.strip()

        # Docstring?
        if l.startswith('"""'):
            self.docstring = ""
            self.add_to_docstring(l.lstrip()[3:])
            return

        self.to.write(" " * self.depths[-1].depth)
        if l[-1] == ":":
            if l == "end:":
                pass
            elif re.compile(r"class\b").match(l):
                self.translate_class(l)
            elif re.compile(r"static class\b").match(l):
                self.translate_class(l)
            elif re.compile(r"enum\b").match(l):
                params = l[4:-1].strip()
                self.typedefs.write("typedef enum %s %s;\n" % (params, params))
                self.hot.write("enum %s\n" % params)
                self.to = self.hot
                self.depths[-1].is_enum = True
            elif re.compile(r"union\b").match(l):
                params = l[5:-1].strip()
                self.hot.write("union\n")
                self.to = self.hot
                self.depths[-1].name = params
                self.depths[-1].is_union = True
            elif re.compile(r"do\b").match(l):
                params = l[2:-1].strip()
                self.to.write("do %s\n" % params)
            elif re.compile(r"for\b").match(l):
                params = l[3:-1].strip()
                self.to.write("for (%s)\n" % translate_conditional_params(params))
            elif re.compile(r"while\b").match(l):
                params = l[5:-1].strip()
                self.to.write("while (%s)\n" % translate_conditional_params(params))
            elif re.compile(r"switch\b").match(l):
                params = l[6:-1].strip()
                self.to.write("switch (%s)\n" % params)
            elif re.compile(r"\bif\b").match(l):
                params = l[2:-1].strip()
                self.to.write("if (%s)\n" % translate_conditional_params(params))
            elif re.compile(r"\belif\b").match(l):
                params = l[4:-1].strip()
                self.to.write("else if (%s)\n" % translate_conditional_params(params))
            elif re.compile(r"else\b").match(l):
                self.to.write("else\n")
            elif re.compile(r"\bdef\b").search(l):
                self.translate_def(l)
            else:
                self.to.write(l + ";\n")
        elif l.startswith("static macro "):
            define = l[len("static macro "):]
            self.to.write("#define %s\n" % define)
        elif l.startswith("macro "):
            define = l[len("macro "):]
            self.hot.write("#define %s\n" % define)
        elif l.startswith("import "):
            names = l[len("import "):].split(",")
            self.translate_import(self.hot, names)
        elif l.startswith("static import "):
            names = l[len("static import "):].split(",")
            self.translate_import(self.to, names)
        elif l.startswith("global "):
            l = l[len("global "):]
            self.to.write(l + ";\n")
            assign = outside_string_find(l, "=")
            if assign >= 0: l2 = l[:assign].rstrip()
            else: l2 = l
            self.hot.write("extern " + l2 + ";\n")
        elif l.startswith("label "):
            l = l[len("label "):]
            self.to.write("%s:;\n" % l)
        elif re.compile(r"pass").match(l):
            self.to.write("/* pass */\n")
        elif l == "#both":
            self.preprocessor_targets = ["header", "implementation"]
        elif l == "#header":
            self.preprocessor_targets = ["header"]
        elif l == "#implementation":
            self.preprocessor_targets = ["implementation"]
        elif l.startswith("#"):
            if "header" in self.preprocessor_targets:
                self.hot.write(l + "\n")
            if "implementation" in self.preprocessor_targets:
                self.to.write(l + "\n")
        else:
            if self.depths[-1].is_enum:
                self.to.write(l + ",\n")
            else:
                self.to.write(l + ";\n")

    def translate_def(self, l):
        mob = re.compile(r"\s*(.*?)\s*def\s*(\w+?)\s*\((.*)\)").match(l)
        if not mob:
            sys.stderr.write("%d: Error, no function!\n" % self.num)
        else:
            retval = mob.group(1)
            name = mob.group(2)
            params = mob.group(3)
            if retval == "": retval = "void"
            if retval in ["static", "inline static", "static inline"]: retval += " void"
            if params == "": params = "void"

            static = "static" in retval.split()

            params2 = []
            last_type = "int"
            for p in params.split(","):
                p = p.strip()
                x = p.split(" ", 1)
                if p == "...":
                    params2.append(p)
                elif len(x) == 1 and p != "void":
                    params2.append(last_type + " " + p)
                else:
                    params2.append(p)
                    last_type = x[0]
            params = ", ".join(params2)
            if not static:
                if self.numbering: self.hot.write("#line %d\n" % self.num)
                self.hot.write("%s %s(%s);\n" % (retval, name, params))
            self.to.write("%s %s(%s)\n" % (retval, name, params))
            self.depths[-1].is_function = True
            self.depths[-1].is_static = static
            self.depths[-1].name = name
            self.depths[-1].definition = "%s %s(%s)" % (retval, name, params)

    def translate_class(self, l):
        mob = re.compile(r"\s*(.*?)\s*class\s*(\w+).*").match(l)
        if not mob:
            sys.stderr.write("%d: Error, no function!\n" % self.num)
            return
        retval = mob.group(1)
        name = mob.group(2)

        static = "static" in retval.split()
        if static:
            self.to.write("typedef struct %s %s;\n" % (name, name))
            self.to.write("struct %s\n" % name)
        else:
            self.typedefs.write("typedef struct %s %s;\n" % (name, name))
            self.hot.write("struct %s\n" % name)
            self.to = self.hot

        self.depths[-1].is_class = True
        self.depths[-1].is_static = static
        self.depths[-1].name = name
        self.depths[-1].definition = name

    def translate_import(self, t, names):
        q = ('"', '"')
        for name in names:
            name = name.strip()
            if name.startswith("global "):
                q = ("<", ">")
                name = name[7:].strip()
            if name:
                if self.numbering: t.write("#line %d\n" % self.num)
                t.write("#include %s%s.h%s\n" % (q[0], name, q[1]))


def string_cb(l, cb):
    outside = ""
    inside = ""
    pos = 0
    start_pos = 0
    is_in_string = ""
    is_escaped = False
    for c in l:
        if is_escaped:
            is_escaped = False
            inside += c
        elif is_in_string:
            if c == "\\":
                is_escaped = True
                inside += c
            elif c == is_in_string:
                is_in_string = ""
                inside += c
                ret = cb(True, start_pos, inside)
                if ret != None: return ret
                start_pos = pos + 1
            else:
                inside += c
        elif c in ['"', "'"]:
            is_in_string = c
            if outside:
                ret = cb(False, start_pos, outside)
                if ret != None: return ret
                outside = ""
            start_pos = pos
            inside = c
        else:
            outside += c
        pos += 1

    if outside:
        return cb(False, start_pos, outside)
    return None

def parenthesis_balance(l, x, y):
    b = 0
    s = 0
    e = 0
    for c in l:
        if e:
            e = 0
        elif s:
            if c == "\\":
                e = 1
            elif s == 1 and c == "\"":
                s = 0
            elif s == 2 and c == "'":
                s = 0
        elif c == "\"":
            s = 1
        elif c == "'":
            s = 2
        elif c == x:
            b += 1
        elif c == y:
            b -= 1
    return b

def colon_find(l):
    mob = re.compile("\s*(\w+)").match(l)
    if mob and not mob.group(1) in ["for", "if", "while", "else", "elif"]: return None
    colon = None
    s = 0
    e = 0
    for i in range(len(l)):
        c = l[i]
        if e:
            e = 0
        elif s:
            if c == "\\":
                e = 1
            elif s == 1 and c == "\"":
                s = 0
            elif s == 2 and c == "'":
                s = 0
        elif c == "\"":
            s = 1
        elif c == "'":
            s = 2
        elif c == ":":
            colon = i
    return colon

def outside_string_replace(l, repl, with):
    out = [""]
    def cb(is_string, pos, sub):
        if is_string:
            out[0] += sub
        else:
            out[0] += re.compile(repl).sub(with, sub)

    string_cb(l, cb)

    return out[0]

def outside_string_find(l, what):
    def cb(is_string, pos, sub):
        if is_string: return
        pos2 = sub.find(what)
        if pos2 >= 0: return pos + pos2
    ret = string_cb(l, cb)
    if ret == None: return -1
    return ret

def translate_conditional_params(params):
    params = outside_string_replace(params, r"\bor\b", "||")
    params = outside_string_replace(params, r"\band\b", "&&")
    params = outside_string_replace(params, r"\bnot\b", "!")
    return params

def main():
    parser = optparse.OptionParser(add_help_option = False)
    parser.add_option("-?", "--help", action = "help"),
    parser.add_option("-i", "--input", help="The input file to parse.")
    parser.add_option("-n", "--name", help="The base name (used for guard and #include).")
    parser.add_option("-N", "--no-line-numbers", help="Do not keep line number information.", action = "store_true")
    parser.add_option("-c", "--c", help="The .c file to generate.")
    parser.add_option("-h", "--h", help="The .h file to generate.")
    parser.add_option("-p", "--prefix", help="An optional extra prefix for include guards.")
    parser.add_option("-d", "--docstrings", help="A text file to which to output all docstrings.")

    options, args = parser.parse_args()

    if args:
        print "Unknow command line options %s." % args
        parser.print_help()
        sys.exit(-1)

    if not options.name and not options.input:
        print "No input or name given."
        parser.print_help()
        sys.exit(-1)

    name = options.name
    if not name:
        name = options.input
        dot = name.rfind(".")
        if dot >= 0:
            name = name[:dot]

    egg = options.input or name + ".egg"
    fin = file(egg)
    fot = file(options.c or name + ".c", "w")
    real_hot = file(options.h or name + ".h", "w")
    guard_prefix = options.prefix or ""
    docstrings = None
    if options.docstrings:
        docstrings = file(options.docstrings, "w")

    translator = Translator(fin, fot, real_hot, name, egg, guard_prefix, docstrings)

    if options.no_line_numbers:
	translator.numbering = False

    translator.header()
    translator.translate()
    translator.footer()

    if translator.dot:
        translator.dot.write('"""module %s\n' % name)
        translator.dot.write('%s\n' % egg)
        translator.dot.write("%s\n" % translator.depths[-1].the_doc)

if __name__ == "__main__":
    main()
